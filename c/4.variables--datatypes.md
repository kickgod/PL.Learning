##### [c 变量和数据类型](#top) <b id="top"></b>
* `计算机要处理的数据（诸如数字、文字、符号、图形、音频、视频等）是以二进制的形式存放在内存中的；`
* `我们将8个比特（Bit）称为一个字节（Byte），并将字节作为最小的可操作单元。` :star:

------

- [x] [`1.变量`](#target1)
- [x] [`2.数据类型（Data Type）`](#target2)
- [x] [`3.sizeof 操作符`](#target3)
- [x] [`4.二进制数、八进制数和十六进制数的表示`](#target4)
- [x] [`5.正负数`](#target5)
- [x] [`6.字符的表示`](#target6)
- [x] [`7.C语言转义字符`](#target7)
- [x] [`8.数据类型转换`](#target8)
- [x] [`9.stdbool.h 新增bool 类型`](#target9)
- [x] [`10.变量的作用域,存储区,生存周期`](#target10)

------

##### [1.变量](#top) <b id="target1"></b>
`标识符就是程序员自己起的名字，除了变量名，后面还会讲到函数名、宏名、结构体名等，它们都是标识符。不过，名字也不能随便起，要遵守规范；C语言规定，标识符只能由字母（A~Z, a~z）、数字（0~9）和下划线（_）组成，并且第一个字符必须是字母或下划线，不能是数字。`

`C语言支持单行注释和多行注释：`
* `单行注释以//开头，直到本行末尾（不能换行）；`
* `多行注释以/*开头，以*/结尾，注释内容可以有一行或多行。`


* `c语言支持 先定义变量，再初始化 也可以在定义的同时进行初始化,一般我们都是定义了一定初始化`

```c
int a;
a = 999;

int b = 25;
```

##### [2.数据类型（Data Type）](#top) <b id="target2"></b>

|`说明`| `字符型`|`短整型`|`整型`|`长整型`|`单精度浮点型`|`双精度浮点型`|`无类型`|
|---|---|----|----|----|----|----|-----|
|`数据类型`| 	char| 	short| 	int| 	long| 	float| 	double| 	void|
|`长度[字节]` |	1| 	2| 	4| 	4| 	4 |	8| 0 |
|`scanf输出符号`|`%c`|`%hd`|`%d`|`%ld`|`%f`|`%lf`|` `|

##### 小数
`小数也可以采用指数形式，例如 7.25×102、0.0368×105、100.22×10-2、-27.36×10-3 等。任何小数都可以用指数形式来表示。`
* `%f 和 %lf 默认保留六位小数，不足六位以 0 补齐，超过六位按四舍五入截断。`
* `将整数赋值给 float 变量时会变成小数。`
* `以指数形式输出小数时，输出结果为科学计数法；也就是说，尾数部分的取值为：0 ≤ 尾数 < 10。`

```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
    float a = 0.302;
    float b = 128.101;
    double c = 123;
    float d = 112.64E3;
    double e = 0.7623e-2;
    float f = 1.23002398;
    printf("a=%e \nb=%f \nc=%lf \nd=%lE \ne=%lf \nf=%f\n", a, b, c, d, e, f);

    return 0;
}
```
`小数还有一种更加智能的输出方式，就是使用%g。%g 会对比小数的十进制形式和指数形式，以最短的方式来输出小数，让输出结果更加简练。所谓最短，就是输出结果占用最少的字符。`

##### 数字
`一个数字，是有默认类型的：对于整数，默认是 int 类型；对于小数，默认是 double 类型。`

```c
long a = 100;
int b = 294;
float x = 52.55;
double y = 18.6;
```
`100 和 294 这两个数字默认都是 int 类型的，将 100 赋值给 a，必须先从 int 类型转换为 long 类型，而将 294 赋值给 b 就不用转换了。`

`52.55 和 18.6 这两个数字默认都是 double 类型的，将 52.55 赋值给 x，必须先从 double 类型转换为 float 类型，而将 18.6 赋值给 y 就不用转换了。`

`如果不想让数字使用默认的类型，那么可以给数字加上后缀，手动指明类型：`

* `在整数后面紧跟 l 或者 L（不区分大小写）表明该数字是 long 类型；`
* `在小数后面紧跟 f 或者 F（不区分大小写）表明该数字是 float 类型。`

```c
long a = 100l;
int b = 294;
short c = 32L;

float x = 52.55f;
double y = 18.6F;
float z = 0.02;
```

##### 小数和整数相互赋值
`在C语言中，整数和小数之间可以相互赋值：`
* `将一个整数赋值给小数类型，在小数点后面加 0 就可以，加几个都无所谓。`
* `将一个小数赋值给整数类型，就得把小数部分丢掉，只能取整数部分，这会改变数字本来的值。注意是直接丢掉小数部分，而不是按照四舍五入取近似值。`

```c
#include <stdio.h>
int main(){
    float f = 251;
    int w = 19.427;
    int x = 92.78;
    int y = 0.52;
    int z = -87.27;

    printf("f = %f, w = %d, x = %d, y = %d, z = %d\n", f, w, x, y, z);
    return 0;
}
//f = 251.000000, w = 19, x = 92, y = 0, z = -87
```

##### [3.sizeof 操作符](#top) <b id="target3"></b>
`获取某个数据类型的长度可以使用 sizeof 操作符 ` **`但是特别注意他无法用来求字符串长度`**

```c
char *address = "255.23.1.2";
int len = sizeof(address) / sizeof(char);
// 结果 len = 4 这显然是不正确的

//C语言的字符串是由字符数组形式保存的，并约定'\0'(ascii码值为0)作为字符串结束符。
//要获得字符串长度，有两种方法可以使用：

//1 使用库函数strlen()。
//strlen声明在string.h中，原型为
/* int strlen(char *str); */

printf("len: %d\n", strlen(address)); //10

/* 第二 根据定义 遍历求长度
int len;
for(len = 0; ; len ++)
    if(str[len] == '\0')break;
*/
```
```c
#include <stdio.h>
int main()
{
    short a = 10;
    int b = 100;

    int short_length = sizeof a;
    int int_length = sizeof(b);
    int long_length = sizeof(long);
    int char_length = sizeof(char);

    printf("short=%d, int=%d, long=%d, char=%d\n", short_length, int_length, long_length, char_length);

    return 0;
}

//在 32 位环境以及 Win64 环境下的运行结果为： short=2, int=4, long=4, char=1
//在 64 位 Linux 和 Mac OS 下的运行结果为： short=2, int=4, long=8, char=1
```
##### [4.二进制数、八进制数和十六进制数的表示](#top) <b id="target4"></b>
`一个数字默认就是十进制的，表示一个十进制数字不需要任何特殊的格式。但是，表示一个二进制、八进制或者十六进制数字就不一样了，为了和十进
制数字区分开来，必须采用某种特殊的写法，具体来说，就是在数字前面加上特定的字符，也就是加前缀。`

##### 二进制
`标准的C语言并不支持上面的二进制写法，只是有些编译器自己进行了扩展，才支持二进制数字。换句话说，并不是所有
的编译器都支持二进制数字，只有一部分编译器支持，并且跟编译器的版本有关系。所以不需要理解`

`二进制由 0 和 1 两个数字组成，使用时必须以0b或0B（不区分大小写）开头，例如： `
```c
//合法的二进制
int a = 0b101;  //换算成十进制为 5
int b = -0b110010;  //换算成十进制为 -50
int c = 0B100001;  //换算成十进制为 33
```

##### 八进制
`八进制由 0~7 八个数字组成，使用时必须以0开头（注意是数字 0，不是字母 o），例如： `
```c
//合法的八进制数
int a = 015;  //换算成十进制为 13
int b = -0101;  //换算成十进制为 -65
int c = 0177777;  //换算成十进制为 65535
```

##### 十六进制
`十六进制由数字 0~9、字母 A~F 或 a~f（不区分大小写）组成，使用时必须以0x或0X（不区分大小写）开头，例如： `
```c
//合法的十六进制
int a = 0X2A;  //换算成十进制为 42
int b = -0XA0;  //换算成十进制为 -160
int c = 0xffff;  //换算成十进制为 65535
```

##### 二进制数、八进制数和十六进制数的输出

|  	|short|	int |	long|
|:---|:----|:----|:----|
|`八进制`|`%ho`|`%o`| `%lo`|
|`十进制`|`%hd`|`%d`| `%ld`|
|`十六进制`|`%hx 或者 %hX`| `%x 或者 %X`| `%lx 或者 %lX`|

##### [5.正负数](#top) <b id="target5"></b>
`符号也是数字的一部分，也要在内存中体现出来。符号只有正负两种情况，用1位（Bit）就足以表示；C语言规定，把内存的最高位作为符号位。以 int 为例，它占用 32 位的内存，0~30 位表示数值，31 位表示正负号`

`short、int 和 long 类型默认都是带符号位的，符号位以外的内存才是数值位。如果只考虑正数，那么各种类型能表示的数值范围（取值范围）就比原来小了一半。`
```c
unsigned short a = 12;
unsigned int b = 1002;
unsigned long c = 9892320;
```
`在编程语言中，计数往往是从0开始，例如字符串 "abc123"，我们称第 0 个字符是 a，第 1 个字符是 b，第 5 个字符是 3。这和我们平时从 1 开始计数的习惯不一样，大家要慢慢适应，培养编程思维。`

`C语言规定，在符号位中，用 0 表示正数，用 1 表示负数。`

##### 无符号数的输出
`--表示没有对应的格式控制符`

<html>
 <head></head>
 <body>
  <table> 
   <tbody> 
    <tr> 
     <td> &nbsp;</td> 
     <th> short</th> 
     <th> int</th> 
     <th> long</th> 
     <th> unsigned short</th> 
     <th> unsigned int</th> 
     <th> unsigned long</th> 
    </tr> 
    <tr> 
     <td> 八进制</td> 
     <td> --</td> 
     <td> --</td> 
     <td> --</td> 
     <td> %ho</td> 
     <td> %o</td> 
     <td> %lo</td> 
    </tr> 
    <tr> 
     <td> 十进制</td> 
     <td> %hd</td> 
     <td> %d</td> 
     <td> %ld</td> 
     <td> %hu</td> 
     <td> %u</td> 
     <td> %lu</td> 
    </tr> 
    <tr> 
     <td> 十六进制</td> 
     <td> --</td> 
     <td> --</td> 
     <td> --</td> 
     <td> %hx 或者 %hX</td> 
     <td> %x 或者 %X</td> 
     <td> %lx 或者 %lX</td> 
    </tr> 
   </tbody> 
  </table>
 </body>
</html>

##### [6.字符的表示](#top) <b id="target6"></b>
`字符类型由单引号' '包围，字符串由双引号" "包围。`

#####  char 类型
* `char 类型不能包含 ASCII 编码之外的字符`
```c
//正确的写法
char a = '1';
char b = '$';
char c = 'X';
char d = ' ';  // 空格也是一个字符
//错误的写法
char x = '中';  //char 类型不能包含 ASCII 编码之外的字符
char y = 'Ａ';  //A 是一个全角字符
char z = "t";  //字符类型应该由单引号包围
```

`我们知道，计算机在存储字符时并不是真的要存储字符实体，而是存储该字符在字符集中的编号（也可以叫编码值）。对于 char 类型来说，它实际上存储的就是字符的 ASCII 码。`

`无论在哪个字符集中，字符编号都是一个整数；从这个角度考虑，字符类型和整数类型本质上没有什么区别。`

`我们可以给字符类型赋值一个整数，或者以整数的形式输出字符类型。反过来，也可以给整数类型赋值一个字符，或者以字符的形式输出整数类型。`

`可以说，是 ASCII 码表将英文字符和整数关联了起来。` [`ASCII码对照表`](http://ascii.911cha.com/)
```c
#include <stdio.h>
int main()
{
    char a = 'E';
    char b = 70;
    int c = 71;
    int d = 'H';
    printf("a: %c, %d\n", a, a);
    printf("b: %c, %d\n", b, b);
    printf("c: %c, %d\n", c, c);
    printf("d: %c, %d\n", d, d);
    return 0;
}
/*
a: E, 69
b: F, 70
c: G, 71
d: H, 72
*/
```
##### 字符串
`其实在C语言中没有专门的字符串类型，我们只能使用数组或者指针来间接地存储字符串。`
```c
char str1[] = "http://c.biancheng.net";
char *str2 = "C语言中文网";
```

##### [7.C语言转义字符](#top) <b id="target7"></b>
`在C语言中，一个字符除了可以用它的实体（也就是真正的字符）表示，还可以用编码值表示。这种使用编码值来间接地表示字符的方式称为转义字符（Escape Character）。`

`转义字符以\或者\x开头，以\开头表示后跟八进制形式的编码值，以\x开头表示后跟十六进制形式的编码值。对于转义字符来说，只能使用八进制或者十六进制。`

`字符 1、2、3、a、b、c 对应的 ASCII 码的八进制形式分别是 61、62、63、141、142、143，十六进制形式分别是 31、32、33、61、62、63。下面的例子演示了转义字符的用法： `

```c
char a = '\61';  //字符1
char b = '\141';  //字符a
char c = '\x31';  //字符1
char d = '\x61';  //字符a
char *str1 = "\x31\x32\x33\x61\x62\x63";  //字符串"123abc"
char *str2 = "\61\62\63\141\142\143";  //字符串"123abc"
char *str3 = "The string is: \61\62\63\x61\x62\x63"  //混用八进制和十六进制形式
```

##### 转义字符
`转义字符的初衷是用于 ASCII 编码，所以它的取值范围有限：`
* `八进制形式的转义字符最多后跟三个数字，也即\ddd，最大取值是\177；`
* `十六进制形式的转义字符最多后跟两个数字，也即\xdd，最大取值是\7f。`

|`转义字符`|`意义`|`ASCII码值（十进制）`|
|:----|:----|:----|
|`\a`|响铃(BEL)|007|
|`\b`|退格(BS)|将当前位置移到前一列|008|
|`\f`|换页(FF)，将当前位置移到下页开头|12||
|`\n`|换行(LF) ，将当前位置移到下一行||01|0|
|`\r`|回车(CR) ，将当前位置移到本行开|013|
|`\t`|水平制表(HT)|009|
|`\v`|垂直制表(VT)|011|
|`\'`|单引号|039|
|`\"`|双引号|034|
|`\\`|反斜杠|092|

`\n和\t是最常用的两个转义字符： `
##### [8.数据类型转换](#top) <b id="target8"></b> 
`数据类型转换就是将数据（变量、数值、表达式的结果等）从一种类型转换为另一种类型。 `

##### 自动类型转换
`自动类型转换就是编译器默默地、隐式地、偷偷地进行的数据类型转换，这种转换不需要程序员干预，会自动发生。`

`占用字节内存少的可以自动转换到占用字节内存大的类型`

`以下是自动类型转换的 对于c语言`
```c
char \
      ---> int --> unsigned --> long --> 【double】 <---- float
short/ 
```

##### 强制类型转换
`自动类型转换是编译器根据代码的上下文环境自行判断的结果，有时候并不是那么“智能”，不能满足所有的需求。如果需要，程序员也可以自己在代码中明确地提出要进行类型转换，这称为强制类型转换。`

`强制类型转换的格式为：`
```c
(type_name) expression
//type_name为新类型名称，expression为表达式。例如：
```

```c
(float) a;  //将变量 a 转换为 float 类型
(int)(x+y);  //把表达式 x+y 的结果转换为 int 整型
(float) 100;  //将数值 100（默认为int类型）转换为 float 类型
```
`下面是一个需要强制类型转换的经典例子：`

```c
#include <stdio.h>
int main(){
    int sum = 103;  //总数
    int count = 7;  //数目
    double average;  //平均数
    average = (double) sum / count;
    printf("Average is %lf!\n", average);
    return 0;
}
//Average is 14.714286!
```
`无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。`

##### [9.stdbool.h 新增bool 类型](#top) <b id="target9"></b> 

`stdbool.h是C标准函数库中一个常用的头文件。它定义了一个布尔类型，于C99中加入。`

```c
/*
bool	_Bool
true	整数常量1
false	整数常量0
__bool_true_false_are_defined	整数常量1
*/

#include <stdio.h>
#include <stdbool.h> 
 
int main(void)
{
 bool a = true, b = false;
 printf("a = %d,  b = %d\n", a, b);
 printf("sizeof(_Bool) = %d\n", sizeof(_Bool));
}

```
##### [10.变量的作用域,存储区,生存周期](#top) <b id="target10"></b> 
`从作用域来看, 变量分为 全局变量和局部变量.`  

`变量的的生存期来看，有点变量在程序运行的整个过程都是存在的，然而有的变量这是在调用其所在的函数式才分配存储单元，而在函数调用结束后就释放了，变量就不复存在。 即变量有两种不同的存储方式：`
`静态存储方式` `动态存储方式` `静态存储方式是指在程序运行期间由系统分配固定的存储空间的方式，而动态存储方式是在程序运行期间根据需要进行动态的分配存储空间的方式`

```c
---------------
|  用户区     |
|-------------|
|   程序区    |
|-------------|
|  静态存储区  |
---------------
|  动态存储区  |
---------------
```
`静态存储区: 存放全局变量 在程序开始时给全局变量分配存储区，程序执行完毕就释放，在程序执行过程中他们占据固定的存储单元，而不是动态的进行分配和释放。`

##### C语言存储类型有四种
`1.auto`:` 自动的，默认`
`2.statis`:`静态的`
`3.register`:`寄存器的`
`4.extern`:`外部的`

##### auto
`可以省略 自动存储类型 属于动态存储方式`

```c
int a = 10;  /* == */  auto int a = 10;
```

##### static 静态存储变量
```c
/*
 n = 3 时 
 time 一开始为0 然后随着函数调用 time 变成 1 2 3....7
*/
void Hanoi(int n, char x, char y ,char z){
   static int time = 0;
   if(n <= 1 ) {
       //printf("%c - > %c\n",x, z);
   }
   else{
        Hanoi(n - 1, x, z, y);
        //printf("%c - > %c\n", x, z);
        Hanoi(n - 1, y, x, z);
   }
   time++;
   printf("- 第%d次调用此函数 -\n", time);
}
/* 输出:
 - 第1次调用此函数 -
 - 第2次调用此函数 -
 - 第3次调用此函数 -
 - 第4次调用此函数 -
 - 第5次调用此函数 -
 - 第6次调用此函数 -
 - 第7次调用此函数 -
*/
```
